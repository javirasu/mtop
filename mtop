#!/bin/bash

usage()
{
	printf '\nmtop [-i secs] [-p pattern] [-l lines] [-m mode] [-h] \n'
	printf '\nmode options: \n\t monitor  - shows CPU, Memory and processes \n\t min \t  - minimalistic mode shows only CPU and Memory \n\t agg \t  - aggregate CPU and Memory by user in the system \n\n'
}

##### MAIN

GREPFILTER='all'
NUMBERLINES=10
REFRESHTIME=3
MODE='monitor'

while [ '$1' != '' ] 
do
	case $1 in
			-i | --interval ) 	shift 
						REFRESHTIME=$1 
						;;
			-p | --pattern  ) 	shift 
						GREPFILTER=$1 
						;;	
			-l | --lines    ) 	shift 
						NUMBERLINES=$1 
						;;
			-m | --mode	)	shift
						MODE=$1
						;;
			-h | --help     )       usage
						exit
						;;
			* ) 			break 
						;;	
	esac
done

clear


while true
do
	if [ "$MODE" = 'monitor' ]; then

		stty -echo      
		printf "%s\n\n" "$(date)"

		top_out=$(top -bn 1)
		free_out=$(free -h)
		     
		echo "$top_out" | awk 'NR>7 { sum += $9; } END {printf("%% CPU free  = \t %-2s \033[K \n", sum);	}'
		echo "$free_out" | grep -w -F 'Mem: ' | awk '{ printf("%% MEM free  = \t %-2s \033[K \n", (100*$4/$2) ); }'
	    
		printf '\n'

		if [ "$GREPFILTER" = 'all' ]
			then
				echo "$top_out" | grep '^[0-9 ]' | awk '{ printf("\033[4m%-8s  %-8s  %-8s  %-8s  %-8s  %-8s  \033[m  \n", $1, $2, $8, $9, $10, $12); }'  | head -n 1
				echo "$top_out" | grep '^[0-9 ]' | awk '{ printf("%-8s  %-8s  %-8s  %-8s  %-8s  %-8s \033[K \n", $1, $2, $8, $9, $10, $12); }' | head -n $((++NUMBERLINES)) | tail -n $NUMBERLINES
		fi
		if [ "$GREPFILTER" != 'all' ]
			then
				echo "$top_out" | grep '^[0-9 ]' | awk '{ printf("\033[4m%-8s  %-8s  %-8s  %-8s  %-8s  %-8s  \033[m  \n", $1, $2, $8, $9, $10, $12); }'  | head -n 1
				echo "$top_out" | grep $GREPFILTER | awk '{ printf("%-8s  %-8s  %-8s  %-8s  %-8s  %-8s \033[K \n", $1, $2, $8, $9, $10, $12); }' | head -n $((++NUMBERLINES)) | tail -n $NUMBERLINES
		fi
		printf '\n'
		echo "$free_out" | head -n 1 | awk '{ printf("\t  %-8s  %-8s  %-8s  \033[K \n", $1, $2, $3); }'
		echo "$free_out" | grep -w -F 'Mem: ' | awk '{ printf("%-8s  %-8s  %-8s  %-8s  \033[K \n", $1, $2, $3, $4); }'
		echo "$free_out" | grep -w -F 'Swap: ' | awk '{ printf("%-8s  %-8s  %-8s  %-8s  \033[K \n", $1, $2, $3, $4); }'
		
	fi



	if [ "$MODE" = 'min' ]; then

		stty -echo      
		printf "%s\n\n" "$(date)"

		top_out=$(top -bn 1)
		free_out=$(free -h)
		    

		echo "$top_out" | awk 'NR>7 { sum += $9; } END {printf("%% CPU free  = \t %-2s \033[K \n", sum);	}'
		echo "$free_out" | grep -w -F 'Mem: ' | awk '{ printf("%% MEM free  = \t %-2s \033[K \n", (100*$4/$2) ); }'
	    
		printf '\n'

	fi


	if [ "$MODE" = 'agg' ]; then

		stty -echo      
		printf "%s\n\n" "$(date)"

		top_out=$(top -bn 1)
		free_out=$(free -h)
		     
		echo "$top_out" | awk 'NR>7 { sum += $9; } END {printf("%% CPU free  = \t %-2s \033[K \n", sum);	}'
		echo "$free_out" | grep -w -F 'Mem: ' | awk '{ printf("%% MEM free  = \t %-2s \033[K \n", (100*$4/$2) ); }'

		printf '\n\n\n'
		printf '\033[4mUSER     %%CPU    %%MEM\033[m\n'

		own=$(id -nu)
		cpus=$(lscpu | grep "^CPU(s):" | awk '{print $2}')

		for user in $(getent passwd | awk -F ":" '{print $1}' | sort -u)
		do
			# print other user's CPU usage in parallel but skip own one because
			# spawning many processes will increase our CPU usage significantly
			if [ "$user" = "$own" ]; then continue; fi
			(top -b -n 1 -u "$user" | awk -v user=$user -v CPUS=$cpus 'NR>7 { sum_cpu += $9; sum_mem += $10 } END { if (sum_cpu > 0.0) printf("%-2s \t %-2s \t %-2s \033[K \n", user, sum_cpu, sum_mem); }') &
			# don't spawn too many processes in parallel
			sleep 0.05
		done
		wait
		# print own CPU usage after all spawned processes completed
		(top -b -n 1 -u "$own" | awk -v user=$own -v CPUS=$cpus 'NR>7 { sum_cpu += $9; sum_mem += $10 } END { if (sum_cpu > 0.0) printf("%-2s \t %-2s \t %-2s \033[K \033[1B \033[K \033[1B \n", user, sum_cpu, sum_mem); }') 		&

	fi

	sleep $REFRESHTIME

        printf '\033[H'
        stty echo
done
